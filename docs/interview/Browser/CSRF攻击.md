## CSRF攻击

CSRF（Cross-site request forgery），跨站请求伪造，指的是攻击者诱导用户点击链接，打开带有攻击的网站，利用用户当前在原网站的登录状态数据信息进去跨站请求。

### CSRF攻击前提条件

- 攻击者想在网站内执行某一个操作，例如更改密码
- 攻击者可以知道/猜测网站对应所需要的参数及值
- 只能通过cookie的方式来验证用户信息的网站

### 场景

例如你正在访问一个网站，点击了黑客为您所准备的点击事件（可能是点击了广告右上角的X，或者其他触发事件的元素），进入到一个新的页面

此时，恭喜你 被攻击了。

当你进入了这个网站时，它可能发生了下面这些事情

### 自动GET请求

例如点击的元素是这样子的
```
<img src="https://origin_web_site.com/get?user=island">
```
在进入页面的时候，发送了以上的请求（包含了用户信息），如果服务器没用做用户信息校验的情况下，服务器就会认为这是一个正常用户的请求，允许进行事件操作（如，修改账号密码，银行转账等）

### 自动POST请求

攻击者填写了一份表单数据，同样携带用户cookie信息，让服务器误以为是一个正常用户在使用，允许进行事件操作。

### 诱导用户的GET请求

黑客的网站可能放着一个链接，诱导用户去点击它
```html
<a href="https://website/get?user=island" taget="_blank">领取现金</a>
```

点击后和自动发送get请求一样，携带着用户信息进行事件操作。

### 防范CSRF

#### Cookie.SameSite属性

使用sameSite标记的cookie，只有在同域名的情况下才会携带cookie信息

> 在chrome51之后，新增了sameSite属性，用来防止CSRF攻击

#### 验证来源站点

> Cookie的同源和浏览器同源策略有点区别
>
> 浏览器：协议、域名和端口都相同即同源
> cookie：域名相同即同源

在http协议中，每个请求都会携带origin和Referer请求标头，用来标记来源域名

通常都是由浏览器自动带上的，前端无法修改它，服务器在接收后可以判断这两个header来确定来源的域名信息

::: warning

如果这两个头部都不存在，应该直接阻止，特别是没有使用CSRFToken作为二次检测。

:::

#### CSRFToken

::: info 

TODO

::: 

### 与XSS区别

和XSS相比，CSRF无需向客户端服务端注入恶意脚本进行攻击，而是跳入新的页面中利用用户的登录态模拟用户的操作