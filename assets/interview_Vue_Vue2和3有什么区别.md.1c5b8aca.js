import{_ as e,c as d,o as c,a as o}from"./app.3b55d36a.js";const V=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"Vue2和3有什么区别","slug":"vue2和3有什么区别","link":"#vue2和3有什么区别","children":[{"level":3,"title":"CMA","slug":"cma","link":"#cma","children":[]},{"level":3,"title":"创建实例方式不同","slug":"创建实例方式不同","link":"#创建实例方式不同","children":[]},{"level":3,"title":"数据变量定义不一样","slug":"数据变量定义不一样","link":"#数据变量定义不一样","children":[]},{"level":3,"title":"props和emit","slug":"props和emit","link":"#props和emit","children":[]},{"level":3,"title":"响应式方案不同","slug":"响应式方案不同","link":"#响应式方案不同","children":[]},{"level":3,"title":"Vue3新增组件","slug":"vue3新增组件","link":"#vue3新增组件","children":[]}]}],"relativePath":"interview/Vue/Vue2和3有什么区别.md"}'),a={name:"interview/Vue/Vue2和3有什么区别.md"},r=o('<h2 id="vue2和3有什么区别" tabindex="-1">Vue2和3有什么区别 <a class="header-anchor" href="#vue2和3有什么区别" aria-hidden="true">#</a></h2><h3 id="cma" tabindex="-1">CMA <a class="header-anchor" href="#cma" aria-hidden="true">#</a></h3><p><code>Vue3</code>新增<code>composition Api</code>，函数式编程</p><p><code>setup</code>函数在生命周期中处于<code>beforeCreate</code>和<code>created</code>中间</p><p><code>setup</code>函数接受<code>props</code>和<code>context</code>两个属性，同时该函数需要返回一个对象</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Vue3.2新增script setup，无需再return一个对象，组件也无需注册可直接使用</p></div><h3 id="创建实例方式不同" tabindex="-1">创建实例方式不同 <a class="header-anchor" href="#创建实例方式不同" aria-hidden="true">#</a></h3><p><code>Vue2</code>在<code>main</code>文件中，直接引入<code>new</code>一个<code>Vue</code>类即可</p><p><code>Vue3</code>需要使用<code>createApp</code>创建实例</p><h3 id="数据变量定义不一样" tabindex="-1">数据变量定义不一样 <a class="header-anchor" href="#数据变量定义不一样" aria-hidden="true">#</a></h3><p>在<code>OptionApi</code>中，变量数据需要定义在<code>data</code>中</p><p>在<code>CMA</code>中，需要使用<code>ref</code>或<code>reactive</code>定义响应式数据</p><h3 id="props和emit" tabindex="-1">props和emit <a class="header-anchor" href="#props和emit" aria-hidden="true">#</a></h3><p>在<code>Vue2</code>中直接使用<code>this</code>即可直接获取到<code>props</code>和<code>emit</code>对象</p><p>而在<code>Vue3</code>需要使用宏函数<code>defineProps</code>和<code>defineEmits</code>，先声明后使用</p><h3 id="响应式方案不同" tabindex="-1">响应式方案不同 <a class="header-anchor" href="#响应式方案不同" aria-hidden="true">#</a></h3><p><code>Vue2</code>：<code>Object.defineProperty</code><code>Vue3</code>: <code>Proxy</code>和<code>reflect</code></p><p><code>Vue2</code>中<code>Object.defineProperty</code>无法完成对数组方法的监听，所以<code>Vue2</code>还重写了<code>Array</code>中的方法</p><p>除了这个，如果直接向<code>data</code>设置一个新的属性，是无法被监听到的</p><p>这时候<code>Vue</code>提供了<a href="https://v2.cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noreferrer"><code>$set</code></a>方法设定一个新的响应式数据</p><h3 id="vue3新增组件" tabindex="-1">Vue3新增组件 <a class="header-anchor" href="#vue3新增组件" aria-hidden="true">#</a></h3><h4 id="fragment" tabindex="-1">Fragment <a class="header-anchor" href="#fragment" aria-hidden="true">#</a></h4><p><code>Vue2</code>中的组件必需要一个根标签，而<code>Vue3</code>不需要，如果有多个根组件时，<code>Vue3</code>会包裹一个<code>Fragment</code>虚拟元素（只处理节点中的<code>children</code>）</p><h4 id="teleport" tabindex="-1">teleport <a class="header-anchor" href="#teleport" aria-hidden="true">#</a></h4><p>用于将指定元素传送（移动）到某个位置</p><p>很典型的一个例子，在<code>Vue2</code>中如果要在页面中显示弹窗的话，遮罩层和弹窗位置可能会受当前页面布局的影响，会导致样式问题</p><p>有了<code>teleport</code>之后，将弹窗元素直接移动到<code>body</code>下面，就不会受到当前页面布局影响</p><h4 id="suspense" tabindex="-1">Suspense <a class="header-anchor" href="#suspense" aria-hidden="true">#</a></h4><p>用于等待异步组件时，渲染一些额外的内容，例如<code>Loading</code>，让用户使用体验更好</p>',29),t=[r];function i(p,n,s,h,l,u){return c(),d("div",null,t)}const f=e(a,[["render",i]]);export{V as __pageData,f as default};
