import{_ as e,o as a,c as t,R as o}from"./chunks/framework.sdpcv3_n.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/Vue/computed和watch的区别.md","filePath":"interview/Vue/computed和watch的区别.md"}'),c={name:"interview/Vue/computed和watch的区别.md"},d=o('<h2 id="computed和watch的区别" tabindex="-1">computed和watch的区别 <a class="header-anchor" href="#computed和watch的区别" aria-label="Permalink to &quot;computed和watch的区别&quot;">​</a></h2><h2 id="computed" tabindex="-1">computed <a class="header-anchor" href="#computed" aria-label="Permalink to &quot;computed&quot;">​</a></h2><p>计算属性，当依赖发生变动时它才会触发重新计算，否则使用的是缓存中的数据</p><p>原生computed不支持异步，但你可以通过<code>vue-async-computed</code>使用异步的computed属性</p><h3 id="应用场景" tabindex="-1">应用场景： <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景：&quot;">​</a></h3><p>当你需要一个属性的值是基于另外一个或以上属性时，通常会使用计算属性了，例如淘宝购物车中的总金额，它需要依赖购物车中的商品继续计算改变。|</p><h2 id="watch" tabindex="-1">watch <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;watch&quot;">​</a></h2><p>监听函数，当依赖属性发生变动时，立即触发回调函数</p><p>回调函数接收两个参数，分别是 变化之后的值，和变化前的值</p><p>在Vue3中，watch支持传入<code>ref[]</code>进行监听，尽可能减少了多个watch的数量</p><p>在Vue3中，如果监听的是一个对象值时，需要使用回调函数<code>()=&gt;props.xx</code>来传递参数</p><h3 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h3><ul><li>deep 对于对象类型是否深监听</li><li>flush 回调执行时机 <ul><li>post 在Vue更新Dom之后触发</li></ul></li><li>immediate 进入页面时立即触发</li></ul><h3 id="应用场景-1" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景-1" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><p>业务中，当一个属性发送改变时，需要执行对应操作时可以使用watch函数。</p>',15),r=[d];function i(h,l,p,u,n,s){return a(),t("div",null,r)}const w=e(c,[["render",i]]);export{_ as __pageData,w as default};
