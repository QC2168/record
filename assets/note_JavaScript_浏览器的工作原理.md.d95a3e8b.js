import{_ as e,o as a,c as t,a as o}from"./app.b2f8a2b9.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"浏览器的工作原理","slug":"浏览器的工作原理","link":"#浏览器的工作原理","children":[]},{"level":2,"title":"浏览器内核","slug":"浏览器内核","link":"#浏览器内核","children":[]},{"level":2,"title":"排版引擎","slug":"排版引擎","link":"#排版引擎","children":[]},{"level":2,"title":"浏览器渲染过程","slug":"浏览器渲染过程","link":"#浏览器渲染过程","children":[]},{"level":2,"title":"JavaScript引擎","slug":"javascript引擎","link":"#javascript引擎","children":[]},{"level":2,"title":"浏览器内核和JavaScript引擎的关系","slug":"浏览器内核和javascript引擎的关系","link":"#浏览器内核和javascript引擎的关系","children":[]},{"level":2,"title":"V8引擎的原理","slug":"v8引擎的原理","link":"#v8引擎的原理","children":[]},{"level":2,"title":"V8引擎架构图","slug":"v8引擎架构图","link":"#v8引擎架构图","children":[]},{"level":2,"title":"相关模块说明","slug":"相关模块说明","link":"#相关模块说明","children":[]}],"relativePath":"note/JavaScript/浏览器的工作原理.md"}'),c={name:"note/JavaScript/浏览器的工作原理.md"},l=o(`<h2 id="浏览器的工作原理" tabindex="-1">浏览器的工作原理 <a class="header-anchor" href="#浏览器的工作原理" aria-hidden="true">#</a></h2><p>在浏览器中<code>JavaScript</code>代码是如何执行的</p><p><code>js</code>可以<code>node</code>里执行，里边有<code>v8</code>引擎</p><p><img src="https://raw.githubusercontent.com/QC2168/note-img/main/202112222019125.png" alt="image-20211222201942856"></p><ul><li>加载<code>html</code>文件（首先） <ul><li>遇到<code>link</code>标签下载对应的<code>css</code>文件</li><li>遇到<code>script</code>标签下载对应的<code>css</code>文件</li></ul></li></ul><h2 id="浏览器内核" tabindex="-1">浏览器内核 <a class="header-anchor" href="#浏览器内核" aria-hidden="true">#</a></h2><p>解析过程是经过浏览器内核处理</p><p>不同浏览器是不同的内核组成的，内核也是浏览器非常重要的组成部分</p><table><thead><tr><th>内核</th><th>说明</th></tr></thead><tbody><tr><td>Gecko</td><td>早期<code>Netscape</code>和<code>Mozilla FireFox</code>浏览器使用</td></tr><tr><td>Trident</td><td>微软开发，<code>IE4-IE11</code>使用，<code>Edge</code>浏览器现使用<code>Blink</code></td></tr><tr><td>Webkit</td><td>苹果基于<code>KHTML</code>开发、开源，用于<code>Safari</code>，（<code>chrome</code>之前也在使用）</td></tr><tr><td>Blink</td><td>是<code>Webkit</code>的一个分支，<code>Google</code>开发，目前应用于<code>Google Chrome</code>、<code>Edge</code>、<code>Opera</code>等</td></tr></tbody></table><h2 id="排版引擎" tabindex="-1">排版引擎 <a class="header-anchor" href="#排版引擎" aria-hidden="true">#</a></h2><p><code>layout engine</code></p><p>内核的另外一个叫法，也有称为浏览器引擎（<code>browser engine</code>），页面渲染引擎（<code>rendering engine</code>），样板引擎</p><h2 id="浏览器渲染过程" tabindex="-1">浏览器渲染过程 <a class="header-anchor" href="#浏览器渲染过程" aria-hidden="true">#</a></h2><p>加载html文件时，遇到script标签之后，会停止解析HTML，去加载执行JavaScript代码</p><p>（JavaScript代码由js引擎处理）</p><p><img src="https://raw.githubusercontent.com/QC2168/note-img/main/202112222033032.png" alt="image-20211222203338833"></p><h2 id="javascript引擎" tabindex="-1">JavaScript引擎 <a class="header-anchor" href="#javascript引擎" aria-hidden="true">#</a></h2><ul><li>JavaScript是高级语言，最终需要被转成机器指令来执行</li><li>我们编写的JavaScript代码无论是给浏览器 / Node执行，最后都是需要被CPU执行的</li><li>但CPU只认识自己的指令集，即机器语言，才能被CPU所执行</li><li>所以我们需要**<code>JavaScript</code>引擎<strong>把</strong><code>JavaScript</code>代码<strong>转化为</strong>CPU指令**来执行</li></ul><p><img src="https://raw.githubusercontent.com/QC2168/note-img/main/202112222045233.png" alt="image-20211222204535128"></p><p>常见的JavaScript引擎</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>SpiderMonkey</td><td>第一款JavaScript引擎，由Brendan Eich开发（也就是JavaScript作者）</td></tr><tr><td>Chakra</td><td>微软开发，用于IE浏览器</td></tr><tr><td>JavaScriptCore</td><td>Webkit中的js引擎，小程序中也用到了，apple开发</td></tr><tr><td>V8</td><td>Google开发的，也帮助chrome从众多浏览器中脱颖而出</td></tr></tbody></table><h2 id="浏览器内核和javascript引擎的关系" tabindex="-1">浏览器内核和JavaScript引擎的关系 <a class="header-anchor" href="#浏览器内核和javascript引擎的关系" aria-hidden="true">#</a></h2><p>（ 以webkit为例 ）</p><p>webCore负责HTML CSS解析、布局、渲染等工作</p><p>JavaScriptCore 解析、执行JavaScript代码</p><h2 id="v8引擎的原理" tabindex="-1">V8引擎的原理 <a class="header-anchor" href="#v8引擎的原理" aria-hidden="true">#</a></h2><p>V8是用C++开发的，是一个开源、高性能的JavaScript和WebAssembly引擎</p><p>可以在多个平台运行，Win系统，macOS，使用X64、IA-21，ARM或者MIPS处理器的linux系统上运行</p><p>V8使用得比较多的有Chrome和Node.js等</p><p>V8可以独立运行，嵌套到任何C++程序中</p><h2 id="v8引擎架构图" tabindex="-1">V8引擎架构图 <a class="header-anchor" href="#v8引擎架构图" aria-hidden="true">#</a></h2><p><img src="https://raw.githubusercontent.com/QC2168/note-img/main/202112222101126.png" alt="image-20211222210135934"></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">const name = &#39;张三&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>V8引擎中的Parse或者<code>PreParser</code>会对这行代码进行词法分析，会生成一个tokens（是一个数组），每个值是一个对象<code>tokens:[{type:&#39;keyword&#39;,value:&#39;const&#39;},{type:&#39;identidfier&#39;,value:&#39;name&#39;} ...]</code></p><p>划分出不同的类型之后，再进行语法分析生成AST抽象语法树（<a href="http://www.astexplorer.net" target="_blank" rel="noreferrer">www.astexplorer.net</a> 推荐一个在线生成AST抽象语法树）之后，经过<code>ignition</code>（V8引擎中一个库）转为<code>bytecode</code>字节码，<code>V8</code>再将组字节码（字节码是跨平台的）转换为<code>CPU</code>的指令集</p><p><code>TurboFan</code>库，收集函数执行的信息，会标签执行次数比较多的函数，并将这个函数优化成机器指令。（后续不再进行转换，提高性能）</p><h2 id="相关模块说明" tabindex="-1">相关模块说明 <a class="header-anchor" href="#相关模块说明" aria-hidden="true">#</a></h2><ul><li><p><code>Parse</code>是一个解析器会将<code>JavaScript</code>代码转成<code>AST</code></p><ul><li>如果函数没有被调用，那么是不会被转换成<code>AST</code>的</li></ul></li><li><p><code>PerParse</code>预解析</p><ul><li><p>不是所有JavaScript代码，在一开始就会被执行，如果对所有<code>JavaScript</code>代码进行解析，必然会影响页面运行效率</p></li><li><p>所以有了**<code>lazy Parsing</code>** 延迟解析方案，它的作用是将不必要的函数进行预解析，只解析暂时需要的代码，而对函数的全量解析是在函数被调用时才会进行</p></li><li><p>例如以下代码，对<code>f2</code>函数进行预解析处理</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">f1</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">f2</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">张三</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">f1</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p><code>Ignition</code>是一个解释器，会将<code>AST</code>转换成<code>ByteCode</code>字节码</p><ul><li>同时会收集<code>TurboFan</code>优化所需要的信息（例如函数参数的类型信息，有了类型才能进行真实的运算）</li><li>如果函数只调用一次，Ignition会执行解析执行<code>byteCode</code></li></ul></li><li><p><code>TurboFan</code>是一个编译器，可以将字节码编译为CPU可以直接执行的机器码</p><ul><li>如果一个函数被多次调用，那么就会被标记为热点函数，并经过<code>TurboFan</code>转换成优化的机器码，提高代码的执行性能</li><li>后续如果执行函数过程中，类型发生了变化，之前优化的机器码不能正确处理，就会逆向转换为字节码</li></ul></li></ul>`,38),n=[l];function d(s,i,r,p,h,u){return a(),t("div",null,n)}const y=e(c,[["render",d]]);export{g as __pageData,y as default};
