import{_ as e,o as s,c as a,a as t}from"./app.28cccbd3.js";const g=JSON.parse('{"title":"CSRF攻击","description":"","frontmatter":{"title":"CSRF攻击","tags":["Browser"]},"headers":[{"level":2,"title":"CSRF攻击","slug":"csrf攻击","link":"#csrf攻击","children":[{"level":3,"title":"CSRF攻击前提条件","slug":"csrf攻击前提条件","link":"#csrf攻击前提条件","children":[]},{"level":3,"title":"场景","slug":"场景","link":"#场景","children":[]},{"level":3,"title":"自动GET请求","slug":"自动get请求","link":"#自动get请求","children":[]},{"level":3,"title":"自动POST请求","slug":"自动post请求","link":"#自动post请求","children":[]},{"level":3,"title":"诱导用户的GET请求","slug":"诱导用户的get请求","link":"#诱导用户的get请求","children":[]},{"level":3,"title":"防范CSRF","slug":"防范csrf","link":"#防范csrf","children":[]},{"level":3,"title":"与XSS区别","slug":"与xss区别","link":"#与xss区别","children":[]}]}],"relativePath":"interview/Browser/CSRF攻击.md"}'),l={name:"interview/Browser/CSRF攻击.md"},n=t(`<h2 id="csrf攻击" tabindex="-1">CSRF攻击 <a class="header-anchor" href="#csrf攻击" aria-hidden="true">#</a></h2><p>CSRF（Cross-site request forgery），跨站请求伪造，指的是攻击者诱导用户点击链接，打开带有攻击的网站，利用用户当前在原网站的登录状态数据信息进去跨站请求。</p><h3 id="csrf攻击前提条件" tabindex="-1">CSRF攻击前提条件 <a class="header-anchor" href="#csrf攻击前提条件" aria-hidden="true">#</a></h3><ul><li>攻击者想在网站内执行某一个操作，例如更改密码</li><li>攻击者可以知道/猜测网站对应所需要的参数及值</li><li>只能通过cookie的方式来验证用户信息的网站</li></ul><h3 id="场景" tabindex="-1">场景 <a class="header-anchor" href="#场景" aria-hidden="true">#</a></h3><p>例如你正在访问一个网站，点击了黑客为您所准备的点击事件（可能是点击了广告右上角的X，或者其他触发事件的元素），进入到一个新的页面</p><p>此时，恭喜你 被攻击了。</p><p>当你进入了这个网站时，它可能发生了下面这些事情</p><h3 id="自动get请求" tabindex="-1">自动GET请求 <a class="header-anchor" href="#自动get请求" aria-hidden="true">#</a></h3><p>例如点击的元素是这样子的</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;img src=&quot;https://origin_web_site.com/get?user=island&quot;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>在进入页面的时候，发送了以上的请求（包含了用户信息），如果服务器没用做用户信息校验的情况下，服务器就会认为这是一个正常用户的请求，允许进行事件操作（如，修改账号密码，银行转账等）</p><h3 id="自动post请求" tabindex="-1">自动POST请求 <a class="header-anchor" href="#自动post请求" aria-hidden="true">#</a></h3><p>攻击者填写了一份表单数据，同样携带用户cookie信息，让服务器误以为是一个正常用户在使用，允许进行事件操作。</p><h3 id="诱导用户的get请求" tabindex="-1">诱导用户的GET请求 <a class="header-anchor" href="#诱导用户的get请求" aria-hidden="true">#</a></h3><p>黑客的网站可能放着一个链接，诱导用户去点击它</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">https://website/get?user=island</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">taget</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">_blank</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">领取现金</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>点击后和自动发送get请求一样，携带着用户信息进行事件操作。</p><h3 id="防范csrf" tabindex="-1">防范CSRF <a class="header-anchor" href="#防范csrf" aria-hidden="true">#</a></h3><h4 id="cookie-samesite属性" tabindex="-1">Cookie.SameSite属性 <a class="header-anchor" href="#cookie-samesite属性" aria-hidden="true">#</a></h4><p>使用sameSite标记的cookie，只有在同域名的情况下才会携带cookie信息</p><blockquote><p>在chrome51之后，新增了sameSite属性，用来防止CSRF攻击</p></blockquote><h4 id="验证来源站点" tabindex="-1">验证来源站点 <a class="header-anchor" href="#验证来源站点" aria-hidden="true">#</a></h4><blockquote><p>Cookie的同源和浏览器同源策略有点区别</p><p>浏览器：协议、域名和端口都相同即同源 cookie：域名相同即同源</p></blockquote><p>在http协议中，每个请求都会携带origin和Referer请求标头，用来标记来源域名</p><p>通常都是由浏览器自动带上的，前端无法修改它，服务器在接收后可以判断这两个header来确定来源的域名信息</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>如果这两个头部都不存在，应该直接阻止，特别是没有使用CSRFToken作为二次检测。</p></div><h4 id="csrftoken" tabindex="-1">CSRFToken <a class="header-anchor" href="#csrftoken" aria-hidden="true">#</a></h4><div class="info custom-block"><p class="custom-block-title">INFO</p><p>TODO</p></div><h3 id="与xss区别" tabindex="-1">与XSS区别 <a class="header-anchor" href="#与xss区别" aria-hidden="true">#</a></h3><p>和XSS相比，CSRF无需向客户端服务端注入恶意脚本进行攻击，而是跳入新的页面中利用用户的登录态模拟用户的操作</p>`,31),o=[n];function r(i,c,p,d,h,u){return s(),a("div",null,o)}const f=e(l,[["render",r]]);export{g as __pageData,f as default};
