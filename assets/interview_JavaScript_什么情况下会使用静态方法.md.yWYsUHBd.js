import{_ as s,o as i,c as a,R as t}from"./chunks/framework.sdpcv3_n.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/JavaScript/什么情况下会使用静态方法.md","filePath":"interview/JavaScript/什么情况下会使用静态方法.md"}'),n={name:"interview/JavaScript/什么情况下会使用静态方法.md"},l=t(`<h2 id="什么情况下会使用静态方法" tabindex="-1">什么情况下会使用静态方法 <a class="header-anchor" href="#什么情况下会使用静态方法" aria-label="Permalink to &quot;什么情况下会使用静态方法&quot;">​</a></h2><p>静态方法可以直接通过类来调用，而不需要事先<code>new</code>出一个类的实例。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClassWithStaticMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  static</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> staticProperty</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;someValue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  static</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> staticMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;static method has been called.&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Class static initialization block called&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ClassWithStaticMethod.staticProperty);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Expected output: &quot;someValue&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ClassWithStaticMethod.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">staticMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Expected output: &quot;static method has been called.&quot;</span></span></code></pre></div><ul><li>当一个方法使用频率比较高时，而且不需要依赖其他类成员，则可以使用静态方法。避免频繁实例化对象导致资源占用问题。</li><li>静态的成员和方法是在构造时就产生的，在运行结束前它不会被垃圾回收掉，会一直占据一定的空间（如果方法不经常被调用，使用实例方法会更好）</li><li>可以用于封装某些方法，例如<code>Math.max()</code>，因为这些对象无需依赖类中的任何一个对象和方法，也属于计算方面的方法，所以采用静态方法会更好</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>静态方法中是无法调用任何非静态的成员的</p><p>静态方法可以被子类重写，但不会影响原父类方法</p></div>`,5),e=[l];function p(h,k,c,d,r,E){return i(),a("div",null,e)}const _=s(n,[["render",p]]);export{g as __pageData,_ as default};
