import{_ as s,o as i,c as a,R as e}from"./chunks/framework.qjNjGLUL.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/JavaScript/作用域-闭包.md","filePath":"interview/JavaScript/作用域-闭包.md"}'),n={name:"interview/JavaScript/作用域-闭包.md"},t=e(`<h2 id="作用域链-scope-chain" tabindex="-1">作用域链 scope chain <a class="header-anchor" href="#作用域链-scope-chain" aria-label="Permalink to &quot;作用域链 scope chain&quot;">​</a></h2><blockquote><p>javascript采用的是词法作用域，函数的作用域在函数定义的时候就决定了</p></blockquote><p>例如下面这个<code>foo</code>函数，当在<code>foo</code>中找不到<code>n</code>时，会向上一层继续查找<code>n</code>这个变量。 这个过程称作为作用域链（<code>scope chain</code>）</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个过程和原型链继承非常相似，但当你在原型链上查找一个不存在的属性时，会返回<code>undefined</code>，而你在作用域链上查找一个不存在的属性，会得到一个<code>ReferenceError</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.x</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// output: undefined</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Uncaught ReferenceError: x is not defined at &lt;anonymous&gt;:1:1</span></span></code></pre></div><h2 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h2><p>定义在<code>foo</code>函数的方法，可以访问定义这个<code>foo</code>函数内部的变量</p><p>定义在<code>foo</code>函数外的方法，无法访问到<code>foo</code>函数内部变量</p><blockquote><p>闭包是函数与声明该函数词法环境的组合</p></blockquote>`,10),p=[t];function h(l,o,c,d,k,r){return i(),a("div",null,p)}const _=s(n,[["render",h]]);export{g as __pageData,_ as default};
