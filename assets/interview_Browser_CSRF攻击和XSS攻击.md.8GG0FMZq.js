import{_ as e,o as a,c as o,R as t}from"./chunks/framework.sdpcv3_n.js";const S=JSON.parse('{"title":"CSRF攻击和XSS攻击","description":"","frontmatter":{"title":"CSRF攻击和XSS攻击","tags":["Browser"]},"headers":[],"relativePath":"interview/Browser/CSRF攻击和XSS攻击.md","filePath":"interview/Browser/CSRF攻击和XSS攻击.md"}'),i={name:"interview/Browser/CSRF攻击和XSS攻击.md"},s=t('<h2 id="csrf攻击" tabindex="-1">CSRF攻击 <a class="header-anchor" href="#csrf攻击" aria-label="Permalink to &quot;CSRF攻击&quot;">​</a></h2><p><code>CSRF</code>（<code>Cross-site request forgery</code>），跨站请求伪造，指的是攻击者诱导用户点击链接，打开带有攻击的网站，利用用户当前在原网站的登录状态数据信息进去跨站请求。</p><h3 id="csrf攻击前提条件" tabindex="-1">CSRF攻击前提条件 <a class="header-anchor" href="#csrf攻击前提条件" aria-label="Permalink to &quot;CSRF攻击前提条件&quot;">​</a></h3><ul><li>攻击者想在网站内执行某一个操作，例如更改密码</li><li>攻击者可以知道/猜测网站对应所需要的参数及值</li><li>只能通过<code>cookie</code>的方式来验证用户信息的网站</li></ul><h3 id="场景" tabindex="-1">场景 <a class="header-anchor" href="#场景" aria-label="Permalink to &quot;场景&quot;">​</a></h3><p>例如你正在访问一个网站，点击了黑客为您所准备的点击事件（可能是点击了广告右上角的<code>X</code>，或者其他触发事件的元素），进入到一个新的页面</p><p>此时，恭喜你 被攻击了。</p><p>当你进入了这个网站时，它可能发生了下面这些事情</p><h3 id="自动get请求" tabindex="-1">自动GET请求 <a class="header-anchor" href="#自动get请求" aria-label="Permalink to &quot;自动GET请求&quot;">​</a></h3><p>例如点击的元素是这样子的</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;img src=&quot;https://origin_web_site.com/get?user=island&quot;&gt;</span></span></code></pre></div><p>在进入页面的时候，发送了以上的请求（包含了用户信息），如果服务器没用做用户信息校验的情况下，服务器就会认为这是一个正常用户的请求，允许进行事件操作（如，修改账号密码，银行转账等）</p><h3 id="自动post请求" tabindex="-1">自动POST请求 <a class="header-anchor" href="#自动post请求" aria-label="Permalink to &quot;自动POST请求&quot;">​</a></h3><p>攻击者填写了一份表单数据，同样携带用户<code>cookie</code>信息，让服务器误以为是一个正常用户在使用，允许进行事件操作。</p><h3 id="诱导用户的get请求" tabindex="-1">诱导用户的GET请求 <a class="header-anchor" href="#诱导用户的get请求" aria-label="Permalink to &quot;诱导用户的GET请求&quot;">​</a></h3><p>黑客的网站可能放着一个链接，诱导用户去点击它</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://website/get?user=island&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> taget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;_blank&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;领取现金&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>点击后和自动发送<code>get</code>请求一样，携带着用户信息进行事件操作。</p><h3 id="防范csrf" tabindex="-1">防范CSRF <a class="header-anchor" href="#防范csrf" aria-label="Permalink to &quot;防范CSRF&quot;">​</a></h3><h4 id="cookie-samesite属性" tabindex="-1">Cookie.SameSite属性 <a class="header-anchor" href="#cookie-samesite属性" aria-label="Permalink to &quot;Cookie.SameSite属性&quot;">​</a></h4><p>使用<code>sameSite</code>标记的<code>cookie</code>，只有在同域名的情况下才会携带<code>cookie</code>信息</p><blockquote><p>在chrome51之后，新增了sameSite属性，用来防止CSRF攻击</p></blockquote><h4 id="验证来源站点" tabindex="-1">验证来源站点 <a class="header-anchor" href="#验证来源站点" aria-label="Permalink to &quot;验证来源站点&quot;">​</a></h4><blockquote><p>Cookie的同源和浏览器同源策略有点区别</p><p>浏览器：协议、域名和端口都相同即同源 cookie：域名相同即同源</p></blockquote><p>在<code>http</code>协议中，每个请求都会携带<code>origin</code>和<code>Referer</code>请求标头，用来标记来源域名</p><p>通常都是由浏览器自动带上的，前端无法修改它，服务器在接收后可以判断这两个<code>header</code>来确定来源的域名信息</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>如果这两个头部都不存在，应该直接阻止，特别是没有使用<code>CSRFToken</code>作为二次检测。</p></div><h4 id="csrftoken" tabindex="-1">CSRFToken <a class="header-anchor" href="#csrftoken" aria-label="Permalink to &quot;CSRFToken&quot;">​</a></h4><p><code>CSRFToken</code>是用来防止攻击者直接伪装我们的请求发送攻击的，它是一个令牌，例如上面我们提到的在当前网站放上<code>url?user=island</code>，携带着参数发送到对应的网站攻击者就能拿到你的用户信息</p><p>现在，如果在传输传输上面新出一个参数<code>CSRFToken</code>，当服务器端在接收数据的时候，发现该参数缺失的，或者是错误的，那么服务器就无法处理当前的请求了，达到保护用户信息安全的目的</p><h2 id="xss攻击" tabindex="-1">XSS攻击 <a class="header-anchor" href="#xss攻击" aria-label="Permalink to &quot;XSS攻击&quot;">​</a></h2><p><code>XXS</code>即（<code>Cross Site Scripting</code>），跨站脚本，为什么不是叫<code>CSS</code>呢？原因是为了<code>CSS</code>（<code>Cascading Style Sheets</code>）做出区分。</p><p>是最普遍的<code>Web</code>应用安全漏洞</p><p>指的是在浏览器中执行恶意脚本，获取用户数据信息并执行对应的操作</p><p><code>XSS</code>一般可以操作一下事件</p><ul><li>窃取<code>Cookie</code>，因为它会在浏览器发送请求时自动发出</li><li>监听用户行为，通过植入脚本方式，获取用户行为发送到目标服务器（攻击者）</li><li>修改<code>Dom</code>，伪造登录表单，植入<code>iframe</code></li><li>在页面中生成广告</li><li>在访问量较大的网站上的<code>XSS</code>可以攻击一些小型网站，实现<code>DDos</code>攻击</li></ul><p><code>XSS</code>也分为三种方式</p><h2 id="存储型" tabindex="-1">存储型 <a class="header-anchor" href="#存储型" aria-label="Permalink to &quot;存储型&quot;">​</a></h2><p>存储型（又称<strong>持久型</strong>）指的是将数据储存起来，将一段恶意脚本代码存储到网站的数据库中，在后续客户端执行的时候就会直接执行这一段脚本代码，达到攻击效果</p><p>例如在评论区页面的提交输入框输入<code>&lt;script&gt;alter(&#39;我是攻击代码&#39;)&lt;/script&gt;</code>，提交的时候如果前后端都没有做好处理，当下次浏览器渲染评论区内容时就会直接执行该代码。</p><p>像现在主流的Vue框架都会对代码做出转义工作，<a href="https://cn.vuejs.org/guide/best-practices/security.html#potential-dangers" target="_blank" rel="noreferrer">详情请查阅</a></p><h2 id="反射型" tabindex="-1">反射型 <a class="header-anchor" href="#反射型" aria-label="Permalink to &quot;反射型&quot;">​</a></h2><p>反射性指的是将恶意脚本作为网络请求的一部分</p><p>例如浏览器发出一个带有<code>query</code>参数的请求</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>http://192.168.0.29/api/get?num=&lt;script&gt;alert(&quot;我是攻击代码&quot;)&lt;/script&gt;</span></span></code></pre></div><p>服务器拿到这个参数时候，再返回给客户端，此时浏览器解析的时候就会执行对应的内容，达到攻击效果</p><p>因为通过了浏览器-&gt;服务器-&gt;浏览器-&gt;解析执行，所以被命名为反射型</p><h2 id="文档型" tabindex="-1">文档型 <a class="header-anchor" href="#文档型" aria-label="Permalink to &quot;文档型&quot;">​</a></h2><p>文档型指的是通过“中间人”的方式进行攻击，在客户端与服务器端进行数据传输的时候通过劫持网络数据包，修改里面的内容。</p><h2 id="如何防范xss" tabindex="-1">如何防范XSS <a class="header-anchor" href="#如何防范xss" aria-label="Permalink to &quot;如何防范XSS&quot;">​</a></h2><h3 id="转义" tabindex="-1">转义 <a class="header-anchor" href="#转义" aria-label="Permalink to &quot;转义&quot;">​</a></h3><p>不要相信任何一方提供的输入，都要对其进行转义工作</p><p>例如<code>1 &lt; 2</code>，转义为<code>1 &amp;lt; 2</code></p><h3 id="防范存储型和反射型" tabindex="-1">防范存储型和反射型 <a class="header-anchor" href="#防范存储型和反射型" aria-label="Permalink to &quot;防范存储型和反射型&quot;">​</a></h3><p>存储型和反射型都是从服务器端取出恶意代码之后，将其插入到<code>html</code>被浏览器执行的。</p><p>常见的预防方法有</p><ul><li>改成纯前端渲染，把代码和数据进行分开 <ul><li>具体做法是</li><li>浏览器先加载一个静态的<code>html</code>，与不包含业务的数据</li><li>通过<code>js</code>网络请求数据，调用<code>DomApi</code>更新到页面上</li></ul></li><li>对<code>HTML</code>进行转义操作 <ul><li>常见的模板引擎都会对<code>HTML</code>内容进行转义（<code>&amp; &lt; &gt; &quot; &#39; /</code>）</li></ul></li></ul><h3 id="拓展-csp" tabindex="-1">拓展 CSP <a class="header-anchor" href="#拓展-csp" aria-label="Permalink to &quot;拓展 CSP&quot;">​</a></h3><p><code>CSP</code>（<code>Content Security Policy</code>，浏览器中的内容安全策略）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本（<code>XSS</code>）和数据注入攻击等。无论是数据盗取、网站内容污染还是恶意软件分发，这些攻击都是主要的手段</p><p>你可以设定你的网站所有数据来源于一个源，例如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Content-Security-Policy: default-src &#39;self&#39;</span></span></code></pre></div><p>严格的<code>CSP</code>在<code>XSS</code>的防范中可以起到以下的作用：</p><ul><li>禁止加载外域代码，防止复杂的攻击逻辑</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域</li><li>禁止内联脚本执行</li><li>禁止未授权的脚本执行</li><li>合理使用上报可以及时发现<code>XSS</code>，利于尽快修复问题</li></ul><h3 id="限制用户输入长度" tabindex="-1">限制用户输入长度 <a class="header-anchor" href="#限制用户输入长度" aria-label="Permalink to &quot;限制用户输入长度&quot;">​</a></h3><p>对于不受信任的输入，应该规定一个合理的长度，虽然无法完全方式<code>XSS</code>攻击，但可以增加<code>XSS</code>攻击的难度</p><h3 id="设置http-only" tabindex="-1">设置Http-only <a class="header-anchor" href="#设置http-only" aria-label="Permalink to &quot;设置Http-only&quot;">​</a></h3><p>禁止<code>js</code>读取<code>cookie</code>，攻击者在植入脚本后无法窃取<code>cookie</code>数据</p><h3 id="csrf攻击与xss区别" tabindex="-1">CSRF攻击与XSS区别 <a class="header-anchor" href="#csrf攻击与xss区别" aria-label="Permalink to &quot;CSRF攻击与XSS区别&quot;">​</a></h3><p>和<code>XSS</code>相比，<code>CSRF</code>无需向客户端服务端注入恶意脚本进行攻击，而是跳入新的页面中利用用户的登录态模拟用户的操作</p>',69),c=[s];function l(d,r,p,h,n,u){return a(),o("div",null,c)}const b=e(i,[["render",l]]);export{S as __pageData,b as default};
