import{_ as a,o as s,c as n,R as e}from"./chunks/framework.sdpcv3_n.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/第一个错误的版本.md","filePath":"algorithm/第一个错误的版本.md"}'),i={name:"algorithm/第一个错误的版本.md"},p=e(`<h2 id="问题描述" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述" aria-label="Permalink to &quot;问题描述&quot;">​</a></h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 <code>API</code> 的次数。</p><h2 id="解答栗子" tabindex="-1">解答栗子 <a class="header-anchor" href="#解答栗子" aria-label="Permalink to &quot;解答栗子&quot;">​</a></h2><h2 id="栗子一" tabindex="-1">栗子一 <a class="header-anchor" href="#栗子一" aria-label="Permalink to &quot;栗子一&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>输入：n = 5, bad = 4</span></span>
<span class="line"><span>输出：4</span></span>
<span class="line"><span>解释：</span></span>
<span class="line"><span>调用 isBadVersion(3) -&gt; false </span></span>
<span class="line"><span>调用 isBadVersion(5) -&gt; true </span></span>
<span class="line"><span>调用 isBadVersion(4) -&gt; true</span></span>
<span class="line"><span>所以，4 是第一个错误的版本。</span></span></code></pre></div><h2 id="栗子二" tabindex="-1">栗子二 <a class="header-anchor" href="#栗子二" aria-label="Permalink to &quot;栗子二&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>输入：n = 1, bad = 1</span></span>
<span class="line"><span>输出：1</span></span></code></pre></div><h2 id="问题分析" tabindex="-1">问题分析 <a class="header-anchor" href="#问题分析" aria-label="Permalink to &quot;问题分析&quot;">​</a></h2><h2 id="编码实现" tabindex="-1">编码实现 <a class="header-anchor" href="#编码实现" aria-label="Permalink to &quot;编码实现&quot;">​</a></h2><h2 id="写法一" tabindex="-1">写法一 <a class="header-anchor" href="#写法一" aria-label="Permalink to &quot;写法一&quot;">​</a></h2><p>暴力法，直接从第一个版本开始遍历。。。。<code>O（N）</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var solution = function(isBadVersion) {</span></span>
<span class="line"><span>    return function(n) {</span></span>
<span class="line"><span>        for(let i = 1; i &lt;= n; i++) {</span></span>
<span class="line"><span>            if(isBadVersion(i)) {</span></span>
<span class="line"><span>                return i;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span>};</span></span></code></pre></div><h2 id="写法二" tabindex="-1">写法二 <a class="header-anchor" href="#写法二" aria-label="Permalink to &quot;写法二&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span></span></span></code></pre></div>`,16),t=[p];function l(o,c,r,d,h,u){return s(),n("div",null,t)}const g=a(i,[["render",l]]);export{_ as __pageData,g as default};
