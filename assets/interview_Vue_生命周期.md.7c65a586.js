import{_ as t,o as e,c as d,a as r}from"./app.101aacdd.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[{"level":3,"title":"生命周期图示","slug":"生命周期图示","link":"#生命周期图示","children":[]},{"level":3,"title":"keepAlive独有钩子","slug":"keepalive独有钩子","link":"#keepalive独有钩子","children":[]},{"level":3,"title":"开发时的钩子","slug":"开发时的钩子","link":"#开发时的钩子","children":[]},{"level":3,"title":"请求数据一般在哪个钩子中执行","slug":"请求数据一般在哪个钩子中执行","link":"#请求数据一般在哪个钩子中执行","children":[]},{"level":3,"title":"created和mounted的区别是什么","slug":"created和mounted的区别是什么","link":"#created和mounted的区别是什么","children":[]}]}],"relativePath":"interview/Vue/生命周期.md"}'),a={name:"interview/Vue/生命周期.md"},n=r('<h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-hidden="true">#</a></h2><h3 id="生命周期图示" tabindex="-1"><a href="https://cn.vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram" target="_blank" rel="noreferrer">生命周期图示</a> <a class="header-anchor" href="#生命周期图示" aria-hidden="true">#</a></h3><p><img src="https://raw.githubusercontent.com/QC2168/note-img/main/20230208141859.png" alt="20230208141859"></p><table><thead><tr><th>hook</th><th>desc</th></tr></thead><tbody><tr><td>setup</td><td>cpa语法</td></tr><tr><td>beforeCreate</td><td>在组件实例初始化完成之后立即调用，此阶段props解析完毕，但data computed还没进行处理</td></tr><tr><td>created</td><td>响应式数据，计算属性，方法已经部署完毕</td></tr><tr><td>beforeMount</td><td>组件、元素挂载之前，即将挂载元素</td></tr><tr><td>mounted</td><td>组件、元素挂载完毕，在这里可以操作el了，但不包括Suspense中内部组件</td></tr><tr><td>beforeUpdate</td><td>响应式数据发生改变，在组件更新之前调用</td></tr><tr><td>updated</td><td>组件因响应式数据而更新之后调用</td></tr><tr><td>beforeUnmount</td><td>组件被卸载之前调用</td></tr><tr><td>unmounted</td><td>组件卸载之后调用，通常应用在事件解绑</td></tr><tr><td>errorCaptured</td><td>捕获到后代组件错误时触发</td></tr></tbody></table><h3 id="keepalive独有钩子" tabindex="-1">keepAlive独有钩子 <a class="header-anchor" href="#keepalive独有钩子" aria-hidden="true">#</a></h3><table><thead><tr><th>hook</th><th>desc</th></tr></thead><tbody><tr><td>activated</td><td>组件插入DOM时调用</td></tr><tr><td>deactivated</td><td>组件在DOM移除之后调用</td></tr></tbody></table><h3 id="开发时的钩子" tabindex="-1">开发时的钩子 <a class="header-anchor" href="#开发时的钩子" aria-hidden="true">#</a></h3><p>仅在开发模式下有效的钩子</p><table><thead><tr><th>hook</th><th>desc</th></tr></thead><tbody><tr><td>renderTracked</td><td>响应式依赖被组件渲染作用跟踪后调用</td></tr><tr><td>renderTriggered</td><td>响应式依赖被组件重新触发渲染之后调用</td></tr></tbody></table><h3 id="请求数据一般在哪个钩子中执行" tabindex="-1">请求数据一般在哪个钩子中执行 <a class="header-anchor" href="#请求数据一般在哪个钩子中执行" aria-hidden="true">#</a></h3><p>在created钩子中，请求数据，因为这个时候data和methods已经部署完毕了，可以直接发送请求将返回来的数据存放到data中</p><p>当然也可以在beforeMount和mounted中调用，因为这三个钩子data已经部署好了，但还是推荐在created中调用会比较好，因为能更快获取到服务器端的数据，减少页面加载事件，用户体验更好</p><h3 id="created和mounted的区别是什么" tabindex="-1">created和mounted的区别是什么 <a class="header-anchor" href="#created和mounted的区别是什么" aria-hidden="true">#</a></h3><p>在上面已经提到created是部署完data，methods和计算属性方法的了，接着在渲染组件到HTML中。</p><p>区别在于created是组件渲染前调用，mounted是组件渲染之后调用。</p><p>如果业务需求需要操作到dom，需要通过ref绑定之后在mounted钩子中获取到对应的元素</p>',16),i=[n];function h(l,o,c,s,p,u){return e(),d("div",null,i)}const b=t(a,[["render",h]]);export{m as __pageData,b as default};
