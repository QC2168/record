import{_ as e,c as o,o as t,a as r}from"./app.78d9c2b4.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"子组件是否可以改变父组件的数据","slug":"子组件是否可以改变父组件的数据","link":"#子组件是否可以改变父组件的数据","children":[{"level":3,"title":"单项数据流","slug":"单项数据流","link":"#单项数据流","children":[]}]}],"relativePath":"interview/Vue/子组件是否可以改变父组件的数据.md"}'),_={name:"interview/Vue/子组件是否可以改变父组件的数据.md"},a=r('<h2 id="子组件是否可以改变父组件的数据" tabindex="-1">子组件是否可以改变父组件的数据 <a class="header-anchor" href="#子组件是否可以改变父组件的数据" aria-hidden="true">#</a></h2><h3 id="单项数据流" tabindex="-1">单项数据流 <a class="header-anchor" href="#单项数据流" aria-hidden="true">#</a></h3><p>在<code>Vue</code>中，所有的<code>props</code>属性都遵循单向数据流原则，当上层数据变动时，<code>props</code>也会自动更新</p><p>但它<strong>无法反向修改</strong>，防止子组件意外修改父组件的数据状态，使得数据流混乱</p><p><strong>如果你在子组件直接执行修改操作，在<code>devTools</code>会有<code>warning</code>操作</strong>，但当修改的值是一个引用传递（对象、数组）的对象，它是可以被修改的</p><p>但，这不意味这我们无法修改<code>props</code>属性，<strong>我们可以通过<code>emit</code>事件将要修改的值告诉父组件</strong>，让父组件来修改</p>',6),c=[a];function d(n,s,i,p,l,h){return t(),o("div",null,c)}const f=e(_,[["render",d]]);export{g as __pageData,f as default};
