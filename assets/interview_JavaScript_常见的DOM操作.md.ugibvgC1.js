import{_ as e,o as a,c as i,R as s}from"./chunks/framework.sdpcv3_n.js";const u=JSON.parse('{"title":"常见的DOM操作","description":"","frontmatter":{"title":"常见的DOM操作","tags":["JavaScript"]},"headers":[],"relativePath":"interview/JavaScript/常见的DOM操作.md","filePath":"interview/JavaScript/常见的DOM操作.md"}'),l={name:"interview/JavaScript/常见的DOM操作.md"},t=s(`<h2 id="常见的dom操作" tabindex="-1">常见的DOM操作 <a class="header-anchor" href="#常见的dom操作" aria-label="Permalink to &quot;常见的DOM操作&quot;">​</a></h2><h3 id="获取节点" tabindex="-1">获取节点 <a class="header-anchor" href="#获取节点" aria-label="Permalink to &quot;获取节点&quot;">​</a></h3><ul><li>getElementById // 根据id查询元素，返回对应的元素</li><li>getElementsByTagName // 根据标签名查询元素，返回的是一个<code>HTML</code>集合，伪数组</li><li>getElementsByClassName // 根据类名查询元素，返回的是一个<code>HTML</code>集合，伪数组</li><li>querySelectorAll // 根据css选择器查询元素，返回的是一个<code>HTML</code>集合，伪数组</li></ul><h3 id="生成节点" tabindex="-1">生成节点 <a class="header-anchor" href="#生成节点" aria-label="Permalink to &quot;生成节点&quot;">​</a></h3><ul><li>createElement // 根据传入的标签名称，创建的元素并返回</li></ul><blockquote><p>新增后并不会立即插入到文档中，而是需要使appendChild追加到指定的位置</p></blockquote><h3 id="修改节点" tabindex="-1">修改节点 <a class="header-anchor" href="#修改节点" aria-label="Permalink to &quot;修改节点&quot;">​</a></h3><ul><li>insertBefore 在某个位置插入一个新元素 <ul><li><code>parentNode.insertBefore(newNode, referenceNode);</code></li></ul></li><li>appendChild 插入一个新的元素在目标元素列表中的尾部 <ul><li><code>element.appendChild(aChild)</code></li></ul></li></ul><h3 id="删除节点" tabindex="-1">删除节点 <a class="header-anchor" href="#删除节点" aria-label="Permalink to &quot;删除节点&quot;">​</a></h3><ul><li>el.removeChild 删除父级元素下的某个子元素</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> removeElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parentEl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> el.parentNode;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parentEl){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       parentEl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(el);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>删除元素需要先通过<code>parent</code>元素，再删除对应的子元素，无法自身删除</p></blockquote>`,12),n=[t];function h(r,o,p,d,c,k){return a(),i("div",null,n)}const _=e(l,[["render",h]]);export{u as __pageData,_ as default};
